java内存模型 
1.什么是java原子性 可见性 有序性
原子性 一些操作不是原子性的 所谓原子性 是这个操作不可分割 例如 a++ new 对象 这个在底层都不是原子的操作  原子性在单线程下没问题 但是在多线程下会有问题
导致错误

可见性 由于缓存的存在 导致一个线程修改的数据 另外一个线程不可见 比如a++这个在线程并发的情况会有问题

有序性  JVM可能会对java的指令进行重排 然后导致 在单线程下出现问题 



1.volatile 这个关键字解决了两个问题 可见行和有序性

什么是可见性 由于线程本地内存(缓存的存在)导致多个线程并发读写一个共享变量的时候，有可能某个线程修改了变量的值，但是其他线程看不到
在程序中出现的问题 针对a++ 来说 有两个步骤 读取 运算 所以 会产生可见性问题  增加一个volatile 这个关键字 可以利用硬件多个线程操作的话 
具体在程序中的应用

最厉害的ConcurrentHashMap 的读操作不加锁的原因就是因为使用这个关键字  当一个线程修改了变量后  读的线程可以感知到  解决数据的一致性

底层原理是在硬件上  当一个线程修改一个用volatile修饰的变量时  会强制其他线程里面的存在的值失效


什么是有序性 设计到hb原则  主要涉及到复杂的指令重排和内存屏障概念
比如：instance =  new Instance(); 这个代码 在JVM执行时有 可以分解为一下三步骤：
memory = allocate(); //1.分配对象的内存空间
ctorInstance(memory); //2.初始化对象
instance = memory; //3.设置instance指向刚分配的内存地址

在JVM执行时，JVM很有可能进行重排序，然后导致单例模式 双锁检查的失效  所以必须在代码中增加volatile字段  这里主要用到的就是volatile的有序性 
 保证代码常的顺序执行 ，思考 这里有没有用到代码的可见性？我感觉这里也有 保证单例在构造出来以后 其他线程即时感知  但是这里主要是使用有序性

