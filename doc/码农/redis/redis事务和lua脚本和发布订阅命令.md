1.redis事务和lua脚本解决了什么问题？

一般很多情况下，redis的执行不止一个命令，需要事务操作，保证原子性

但是特殊情况下(分布式锁) 我们需要服务端一次执行更复杂的操作，主要是有一些逻辑判断，比如分布式锁，此时lua脚本  可以解决事务问题



1.首先应该明确的是redis的操作命令操作都是具有原子性的 ？因为redis是单线程的操作啊  也就是说在redis的服务端的命令执行其实是one by one进行执行的
但是 在实际中有一些场景需要命令的执行具有原子性(要么执行成功,要么全部执行失败,或者说在执行这些命令的过程中不希望其他的客户端插入)这个时候需要用redis的事务机制
所以几条指令一起执行 就不具有原子性(最明显的操作是在利用redis实现分布式锁的时候，加锁操作，由几条指令组成不具有原子性)
这时候需要用事务操作 来保证操作的原子性 
但是redis的事务机制和数据库的事务机制不同？怎么不同？
   这个需要用底层的机制来说明 首先redis的事务不具有回滚的性质 
   具体来收分为两种情况：1 在执行中出现语法错误，redis会不会继续执行？(这个存疑) 2 执行中出现运行错误，这个可以肯定事务会继续执行 不会回滚
   针对这种情况 redis增加一个watch命令 有点类似于乐观锁 WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。
   监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）
   
   注意redis一旦执行exec命令 便不再接收其他客户端的请求

2.事务怎么执行？
  redis事务命令 multi 开启事务  exec  提交事务
  底层实现：redis开启事务命令multi 在执行过程中会将逐条命令入队 然后在执行exec的时候也就是提交的时候 逐条从队列里面取数据进行执行
           放弃事务用discard命令
           
  redis的watch是什么机制？
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
3.发布订阅命令
  
     



