1.分布式ID中的情况 
一般解决分布式ID简单的实现有两种
  利用mysql或者oracle中的自增主键来实现  数据库可能出现单点故障问题
  利用UUID  全是字符无法利用排序等
  
2.什么是雪花算法？
  SnowFlake算法生成id的结果是一个64bit大小的整数 
 ![]( https://img2018.cnblogs.com/blog/1112483/201909/1112483-20190911162642009-1039680554.png)
 
 3.使用雪花算法怎么解决几个问题 ？能够支持每秒钟多少的并发量？
 https://blog.csdn.net/lq18050010830/article/details/89845790
 第一个部分，是 1 个 bit：0，这个是无意义的。  //为什么不使用第一位或者第一位默认是0 因为在java里第一位是1 表示的是负数 id明显是正数  统一用0
 第二个部分是 41 个 bit：表示的是时间戳。//用41位来表示毫秒值 41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2 ^ 41 - 1 个毫秒值，换算成年就是表示 69 年的时间
 第三个部分是 5 个 bit：表示的是机房 id，10001。
 第四个部分是 5 个 bit：表示的是机器 id，1 1001。
 //代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器。
 但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 2 ^ 5 个机房（32 个机房），每个机房里可以代表 2 ^ 5 个机器（32 台机器），也可以根据自己公司的实际情况确定。
 
 第五个部分是 12 个 bit：表示的序号，就是某个机房某台机器上这一毫秒内同时生成的 id 的序号，0000 00000000。
  //12 bit 可以代表的最大正整数是 2 ^ 12 - 1 = 4096，也就是说可以用这个 12 bit 代表的数字来区分同一个毫秒内的 4096 个不同的 id