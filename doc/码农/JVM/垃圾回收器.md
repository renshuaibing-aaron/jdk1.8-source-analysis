1.Serial和Serial Old垃圾回收器 分别用来回收新生代和老年代垃圾对象
缺点：单线程运行 垃圾回收的时候会停止我们自己写的系统 让我们的系统直接卡死 然后进行垃圾回收 一般不用

2.ParNew和CMS垃圾回收器
ParNew 新生代的垃圾回收器 CMS老年代的垃圾回收器
使用“-XX:ParallelGCThreads”参数  
说明ParNew 垃圾回收器和Serial其实底层原理是一样的 不同的是一个是单线程的一个是多线程的 具体使用哪个垃圾回收器 具体情况具体分析 比如如果是服务端可以设置
ParNew垃圾回收器 充分利用服务器的多核资源 如果是客户端用Serial就可以了这个时候 因为线程的切换也要代价
但是 注意的是这两个回收器都会产生Stop the world问题

由上文可以知道 采用Serial进行年轻代的垃圾回收 是单线程的 如果计算机是多核CPU 明显采用Serial是不合适的 所以一般为了发挥计算机最大的性能
可以采用ParNew垃圾回收器  

https://www.jianshu.com/p/86e358afdf17                           
CMS进行垃圾回收的四个阶段 说明这里采用的是标记清除算法(个人感觉主要是因为老年代对象比较大进行压缩整理影响性能，因为这个需要停顿) 会产生垃圾碎片
        初始标记  停止应用的所有工作线程(stop the world)  然后标记只被GcRoots引用的对象(方法的局部变量和类的静态变量，注意类的实例变量不会被标记)
        并发标记 并发执行 遍历所有老年代中的对象查看是不是被GcRoots间接引用了 比较耗时 但是因为并发 影响不大
        重新标记  停止工作线程 针对第二阶段的产生的或者变动的对象进行重新标记 
        并发清理  并发执行清理 表现整理 清理对象 回收在对象图中不可达的空间

CMS垃圾回收器的缺点
    1.浮动垃圾 (由于是并发清理 这时候会产生一些新的垃圾对象 这些垃圾对象只能在下次垃圾回收的时候进行回收掉)
    2.内存碎片,这个主要是跟CMS的垃圾回收算法有关 CMS采用的是垃圾回收算法是标记清除(G1是标记整理清除) 明显会产生一些小的碎片导致无法利用



3.G1垃圾回收器 统一收集新生代和老年代 采用更加优秀的算法设计 
为什么要采用G1 垃圾回收器 因为之前的垃圾回收器都或多或少的产生问题 stop the world问题导致应用线程的停顿
采用G1垃圾回收器 可以最大复度的减少停顿时间 G1 的主要关注点在于达到可控的停顿时间，在这个基础上尽可能提高吞吐量
如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了
使用“-XX:+useG1GC”参数 

而 G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。
和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活
 1、年轻代收集
 2、并发收集，和应用线程同时执行
 3、混合式垃圾收集
 *、必要时的 Full GC

G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间
简述 G1，可预测停顿时间，是怎么做到的？


垃圾回收器G1和CMS的比较
https://segmentfault.com/q/1010000021658061?utm_source=tag-newest

首先要说明，没有一款垃圾收集器是完美无缺的，只能分场景选择最适合的垃圾收集器。由于 G1 和 CMS 相比其他收集器都有停顿时间短的特点，所以主要对比这两个收集器：

G1 优点：
停顿时间短；用户可以指定最大停顿时间； 因为G1的垃圾回收是按照regin区域进行回收的 可以根据用户的指定停顿时间动态合理分配
不会产生内存碎片：G1 的内存布局并不是固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域 (Region)，
G1 从整体来看是基于“标记-整理”算法实现的收集器，但从局部 (两个Region 之间)上看又是基于“标记-复制”算法实现，
不会像 CMS (“标记-清除”算法) 那样产生内存碎片。
G1 缺点：简单来说就是浪费内存
G1 需要记忆集 (具体来说是卡表)来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，
可能达到整个堆内存容量的 20% 甚至更多。而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。

 