1.垃圾收集的方法： 标记清除 (这个会有垃圾碎片) 标记整理(老年代算法)  复制算法(这个是年轻代的算法)
最开始的算法 最原始的算法 会产生垃圾碎片
复制算法 解决了垃圾碎片问题 但是会造成空间浪费
年轻代的算法  分为三个区间 一个eden 两个survior区 比例是8：1：1 注意垃圾回收的过程 
  首次分配到eden区 然后如果eden快满了 就触发minorGC 把eden的对象 转移到survior中的from区 此时eden空了  然后
  eden快满了 就会把eden和survior中对象转移到to区 清空eden和survior中的from区 一次类推
老年代的算法
  一个对象不可能总是在年轻代里面 问题 什么情况下 年轻代的对象会进入到老年代里面？
  1.在经历15次的垃圾回收之后会进入老年代(这可以通过参数设置可以通过JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁)
  2.动态年龄判断 这个和上个判断是一致的 希望哪些长期存活的对象尽早的进入老年代里面
  3.大对象直接进入老年代  “-XX:PretenureSizeThreshold”
  4.MinorGc 对象太多，因为我们知道miniorGC是回收Eden和S1区的有可能S2区中放不下 这个时候会提前进入老年代
  5.其实还有一种情况 就是针对4的对象放入老年代也放不下 会出现老年代的空间担保原则
  也就是说在MiniorGc之间会进行一次判断 判断这个存活的年轻代的对象的大小和老年代剩余空间的大小比较 然后比较老年代内存的剩余大小和平均年轻代的
  平均大小 如果失败了 就会触发一次FullGc(两个判断都生效)
  或者直接进行MinorGc
  然后MiniorGc后发现存活的大小还是大于老年代的大小 这时候会直接进行FullGC



2.垃圾回收器的种类 Serial CMS G1
3.针对堆外内存不受Gc的控制，怎么释放？  netty的解决方案是什么？
https://blog.csdn.net/hellozhxy/article/details/102728206  
 堆外内存需要调用FULL  GC才可以
 
 
 4.怎么设置调试堆内存的空间大小
 -Xms4M -Xmx4M -Xmn2M  什么时候触发minor GC
 
 
 5.垃圾回收器的种类和怎么设置？
 CMS
 
 G1
 
 6.在生产实践过程中如何预估系统的内存使用模型 然后设置年轻代 老年代的大小 以及采用什么模式垃圾回收器
 
 需要思考的问题有  系统每秒占用多少内存 多长时间触发一次Minor Gc 一般Minior Gc后有多少的存活对象  survivor可以放的下吗
 会不会因为survior放不下 导致对象进入老年代 会不会因为动态年龄规则判断进入老年代
 
 
 7.一个对象什么时候可以被回收？什么是GCRoots 引用 什么情况下可以作为GCRoots
 或者说 JVM如何解决循环引用的问题 
 一个对象被强引用并不能保证对象不被回收  JVM的垃圾回收机制除了检查对象是否被引用外 还要判断该对象至少被一个GcRoots对象直接或者间接引用
 一个对象没有被引用 就可以被回收 
 什么是GCRoots 对象有哪些
    方法的局部变量 每个线程当前的函数调用栈 从栈顶到栈底的每个函数里面的局部变量
    和类的静态变量
    被JNI中引用到的变量
 都是可以称为GcRoots 要注意这个局部变量其实是在栈里面的 当一个方法执行完后
 其栈帧会消失 然后就是会失去变量的引用 然后会被回收掉
 
 
 8.什么时候会触发FullGc  一般触发FullGc就两个时机 一个是MinorGc前 一个是MinorGc后
 什么是老年代空间担保规则？
 
 
 9.  判断对象是否已死（两次标记：可达性分析+finalize方法）
 
 