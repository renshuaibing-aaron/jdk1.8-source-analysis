1. 方法区会不会进行垃圾回收？
方法区肯定需要垃圾回收 回收的时机是 类的实例变量都已经垃圾回收了  加载这个类的类加载器已经被回收了  该类的Class对象
没有任何引用



2.JVM大概构成：类加载器 内存(运行时数据取) 执行引擎(本质是CPU) 本地接口  本地库
 内存：线程共享: 方法区 (JDK7 JDK8之后变成永久区) 存放常量池和类变量   堆
      线程不共享：程序计数器 本地方法栈  JAVA栈


1.JVM中有哪几块内存区域？Java 8之后对内存分代做了什么改进
在之前JVM主要有三大块栈内存(线程) 堆内存(对象) 永久区(类信息+常量池)
在JDK8以后 对JVM的内存区域的调整 永久区里面的常量池放到堆内存里面 永久区变成了元数据区(metaspace)

注意虚拟机栈和本地方法栈的区别  ：
  虚拟机栈 服务对象是执行java方法
  本地方法栈服务对象是执行native方法  

2.你知道JVM是如何运行起来的吗？我们的对象是如何分配的？

3.说说JVM在哪些情况下会触发垃圾回收
首先需要了解JVM的堆内存分代模型，这里需要明确的是只有堆内存才有分代模型，堆内存总体上可分为年轻代和老年代
其中年轻代可分为eden和两个s区，比例大概是8:1:1
然后eden区满了，触发第一次垃圾回收，youngGc
什么对象的堆内存会回收，该对象不被任何栈针引用，并且不被任务类对象引用即可触发回收

4.说说JVM的年轻代垃圾回收算法？对象什么时候转移到老年代
首先说明的是JVM的年轻代算法是复制算法，简单的说是，在第一yongGc时，会把eden区里面的存活的对象复制到S1区，然后第二次
yongGc时，把S1区和eden区里面的对象复制到S2区，然后把eden区和S1区里面的对象删除，再一个在垃圾回收过程中JVM的工作线程会停止的

什么时候对象会转移到老年代？分几种情况假如一个对象在15次yongGc中都没有被清楚，那么便转移到老年代；有些对象比较大，在一开始new时就放到
老年代比如大于100M的对象 ，有些对象在第一YongGc时会转移到老年代   


5.说说老年代的垃圾回收算法？常用的垃圾回收器都有什么

首先可以知道的老年代的对象一般都不是垃圾，都一些大对象或者是spring容器引用的对象，所以不能使用年轻代的复制算法，另外老年代的垃圾回收比较耗时
之前老年代的垃圾回收算法使用的是标记-清除，这样的话会产生一些内存碎片无法使用，所以现在一般的jdk采用的是标记-整理算法

针对垃圾回收器，不同的版本的JDK采用的垃圾回收器也不一样，在JDK1.8之前采用的parnew+cms 组合，parnew针对年轻代回收，cms针对老年代进行回收，
其中cms在针对老年代进行回收时，会采取多线程进行，不会停止工作线程 
在JDK9之后 主推的是g1垃圾回收器，这个对年轻代和老年代都可以使用


6.你们生产环境中的Tomat是如何设置JVM参数的？如何检查JVM运行情况

7.你在实际项目中是否做过JVM GC优化，怎么做的


8.Java中int变量的长度时多少？
  在Java中int变量的长度是固定值都是32位  4字节
  
9.什么是直接内存？怎么使用的？API是什么？有什么好处？和零拷贝有什么关系？








































