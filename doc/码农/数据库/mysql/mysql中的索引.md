索引的数据结构采用的是B+树结构
什么是聚集索引 什么是非聚集索引
InnoDB有且只有一个聚簇索引，而MyISAM中都是非聚簇索引

所谓聚集索引就是把索引和数据在一起存放 B+树是一种聚集索引 找到了索引便找到了数据
非聚集索引是查找索引 需要回表 才可以查到具体的数据 为什么需要回表说明 叶子节点保存的不是数据 而是表的内存地址 然后进行二次查表即可


针对InnoDb存储引擎 的查找过程 现在非聚集索引里面查找  然后在叶子节点查找找到主键 然后再聚集索引里面找到值

select * from test where val=4 limit 300000,5
优化过后的代码
select * from test a inner join (select id from test where val=4 limit 300000,5) b on a.id=b.id;

分析为什么会提高搜索速度？
https://mp.weixin.qq.com/s?__biz=MzU2Njg3OTU1Mg==&mid=2247485312&idx=1&sn=001c4e6f714d682b9ab14eeed30d1e73&chksm=fca4f3afcbd37ab9d29ae2565d05fe5cb84616002787a078d5fc8789eaafa3540d1c54494d9f&scene=27#wechat_redirect

2.什么是最左前缀匹配原则？ 匹配左边的列 其实这个本质都是一样的 根据索引的数据结构 可以很容易知道
    匹配最左边的列 
    匹配列前缀(针对字符串索引) SELECT * FROM person_info WHERE name LIKE 'As%'; 索引有效
                            SELECT * FROM person_info WHERE name LIKE '%As%'; 索引失效
    匹配范围值

对于复合索引 特别要注意索引失效的情况 如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列


3.深入理解InnoDB中的聚集索引和辅助索引(B+索引)
https://blog.csdn.net/wrs120/article/details/91126531
聚集索引：按照每张表的主键构成一棵B+树 叶子节点存放整张表的行记录数据 这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建（后边会介绍索引相关的语句），InnoDB存储引擎会自动的为我们创建聚簇索引。
另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引

辅助索引：叶子节点并不包含行记录的全部数据 又叫二级索引 表示的是非主键索引 数据库会根据用户自定义的索引创建索引文件 
     但是注意二级索引需要回表操作(不可能把所有的数据文件都存到叶子节点)

联合索引： 联合索引也是一个B+树 只不过键值的数量为多个 
(联合索引的最左匹配原则：最左优先 以最左为起点的任何连续索引都可以匹配的上 同时遇到> < between like就会停止匹配 )

覆盖索引：从辅助索引里面就可以得到查询的记录 而不需要查询聚集索引的记录
       覆盖索引其实意思就是 保证SQL只需要索引就可以返回查询所需要的数据  不必通过二级索引查找主键后再查询数据  
       举例select  uid from user  where gid=2 order by creeat_time ASC  limit 10;
      怎么解决:建立联合索引 把查找的键写入索引
       

唯一索引：唯一索引和主键索引的区别

具体到sql执行过程中 采用何种索引有优化器说了算 优化器会根据具体的情况进行分析

MySQL/SQLlite 键和索引的区别，键值和唯一索引的区别


索引下推
    给了三个查询 where分别是
    a=? b=?
    b=? c=?
    c=? a=?
    问怎么建索引查找效率高



mysql的索引为什么采用B+树索引？为什么不采用二叉树(红黑树和平衡二叉树)
mysql所索引什么时候会才采用hash索引？？
https://blog.csdn.net/zhaoliang831214/article/details/89393466
https://blog.csdn.net/buyulian/article/details/77996253



在数据表底层的B+树的叶子节点为啥用类似双链表连接起来？
 当我们在使用范围查找的时候只要找到边界值就可以通过指针查找其他需要的数据 就不用再从根节点进行遍历 减少了消耗时间 增加了效率























