1.首先说明的是事务的基本特性，这个不再赘述
其次数据库就是一个特殊的文件系统,特殊在具有事务的功能
为了解决事务中出现的并发问题 数据库引入了数据的隔离级别 mysql共四种隔离级别
底层怎么实现,不同的数据库产品有不同的实现 这里主要介绍Mysql中InnoDB存储引擎的情况下(MyISM存储引擎没有事务概念,讨论没有意义)
怎么实现 加锁 利用加锁的不同场景来推荐不同的情况  并且在Mysql中还有MVCC(乐观锁的解决方案)
MYsql的隔离级别默认是可以可重复读 并且在可重复读的隔离级别情况下 牛逼的解决了幻读问题

https://blog.csdn.net/suifeng629/article/details/99412343
https://tech.meituan.com/2014/08/20/innodb-lock.html
https://www.cnblogs.com/cchust/p/4255499.html


3.


脏读：（同时操作都没提交的读取）脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。
例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。
解决办法：把数据库的事务隔离级别调整到READ_COMMITTED


不可重复读：（同时操作，事务一分别读取事务二操作时和提交后的数据，读取的记录内容不一致）
不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。 
例如：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。
 解决办法：把数据库的事务隔离级别调整到REPEATABLE_READ
 幻读：（幻读是不可重复读的特殊场景，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致）
 例如：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入（注意时插入或者删除，不是修改））了一条具体分数的记录，
 当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。
 解决办法：把数据库的事务隔离级别调整到SERIALIZABLE_READ
 
 通过在写的时候加锁，可以解决脏读。通过在读的时候加锁，可以解决不可重复读。
 通过串行化，可以解决幻读。
