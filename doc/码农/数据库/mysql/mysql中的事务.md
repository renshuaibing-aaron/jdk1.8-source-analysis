1.首先说明的是事务的基本特性，这个不再赘述
ACID的基本特性
A: (Atomicity)原子性  要么全部成功 要么全部失败
C:(Consistency) 一致性
I:(Isolation) 隔离性(四种隔离级别)
D:(Durability)持久性
//注意和分布式系统CAP的区别   
C (Consistency)一致性
A(Availability)可用性
P (Partition tolerance)分区容错性
其次数据库就是一个特殊的文件系统,特殊在具有事务的功能
为了解决事务中出现的并发问题 数据库引入了数据的隔离级别 mysql共四种隔离级别
底层怎么实现,不同的数据库产品有不同的实现 这里主要介绍Mysql中InnoDB存储引擎的情况下(MyISM存储引擎没有事务概念,讨论没有意义)
怎么实现 加锁 利用加锁的不同场景来推荐不同的情况  并且在Mysql中还有MVCC(乐观锁的解决方案)
MYsql的隔离级别默认是可以可重复读 并且在可重复读的隔离级别情况下 牛逼的解决了幻读问题

https://blog.csdn.net/suifeng629/article/details/99412343
https://tech.meituan.com/2014/08/20/innodb-lock.html
https://www.cnblogs.com/cchust/p/4255499.html


3.
多个事务并发的对数据页加载到buffer pool的数据进行操作的时候会出现并发问题 四类问题脏写 脏读 不可重复度 幻读

脏写 当两个事务同时尝试去更新某一条数据记录时，就肯定会存在一个先一个后。而当事务A更新时，事务A还没提交，事务B就也过来进行更新，覆盖了事务A提交的更新数据，这就是脏写
解决办法 事务隔离级别设置为读未提交(在生产实践中没有人会傻到设置这个隔离级别)  读未提交的底层会进行加锁(独占锁)

脏读：（同时操作都没提交的读取）脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。
例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。
解决办法：把数据库的事务隔离级别调整到READ_COMMITTED


不可重复读：（同时操作，事务一分别读取事务二操作时和提交后的数据，读取的记录内容不一致）
不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。 
例如：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。

 解决办法：把数据库的事务隔离级别调整到REPEATABLE_READ 
 注意这个时候还是会出现幻读的 比如select * from table where id >10  这个可重复读只是保证 某个ID的行数据被锁住 然后会可重复度 但是还是会出现幻读
 
 
      这里要搞明白 幻读和不可重复读的区别
 幻读：（幻读是不可重复读的特殊场景，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致）
 例如：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入（注意时插入或者删除，不是修改））了一条具体分数的记录，
 当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。
 解决办法：把数据库的事务隔离级别调整到SERIALIZABLE_READ
 
 通过在写的时候加锁，可以解决脏读。通过在读的时候加锁，可以解决不可重复读。
 通过串行化，可以解决幻读。


4.mysql的隔离级别是如何实现的？有哪些隔离级别和SQL隔离级别的区别？
mysql的默认隔离级别是RR 也就是可重复读 但是牛逼的是mysql在可重复读的基础上解决 幻读问题 


4.https://blog.csdn.net/nanxiaotao/article/details/80412196


5.MVCC 的知识


6.数据库底层是怎么解决原子性的

https://blog.csdn.net/xmt1139057136/article/details/104912243
   其实数据库的ACID性质都是靠存储引擎来解决的 那么在存储引擎中的几个重要的日志概念为ACID的性质提供了技术上的保障


